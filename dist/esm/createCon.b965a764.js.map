{"mappings":"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","sources":["src/_internal/createCon.ts"],"sourcesContent":["import { create, type Draft, isDraft, } from 'mutative';\nimport type { ActRecord, } from '../types/ActRecord';\nimport type { CreateActsProps, } from '../types/CreateActsProps';\nimport type { DS, } from '../types/DS';\nimport type { EstadoHistory, } from '../types/EstadoHistory';\nimport type { EstadoRecord, } from '../types/EstadoRecord';\nimport type { GetDraftRecord, } from '../types/GetDraftRecord';\nimport type { GetStringPathValue, } from '../types/GetStringPathValue';\nimport type { Immutable, } from '../types/Immutable';\nimport type { NestedRecordKeys, } from '../types/NestedRecordKeys';\nimport type { Option, } from '../types/Option';\nimport compareCallback, { type CompareCallbackReturn, } from './compareCallback';\nimport createArrayPathProxy from './createArrayPathProxy';\nimport createHistory from './createHistory';\nimport findChanges from './findChanges';\nimport getCacheStringPathToArray from './getCacheStringPathToArray';\nimport getDeepArrayPath from './getDeepArrayPath';\nimport getDeepValueParentByArray from './getDeepValueParentByArray';\nimport noop from './noop';\n\nconst opts = Object.freeze( {}, );\n\nexport default function createCon<\n\tState extends DS,\n\tActs extends ActRecord,\n>(\n\tinitial: State,\n\toptions: Option<State, Acts> = opts as Readonly<Option<State, Acts>>,\n) {\n\tif ( initial == null || typeof initial !== 'object' ) {\n\t\tthrow new Error( `createCon can only work with plain objects \\`{}\\` or arrays \\`[]. Value is ${initial} of type ${typeof initial}`, );\n\t}\n\tlet history = createHistory( { initial, }, );\n\tconst {\n\t\tafterChange = noop,\n\t\tdispatcher = noop,\n\t} = options;\n\tconst compare = compareCallback( options.compare, );\n\tconst arrayPathMap = new Map<string | number, Array<string | number>>();\n\n\tfunction setHistory( nextHistory: EstadoHistory<State>, ) {\n\t\thistory = nextHistory;\n\t\tdispatcher( history as Immutable<EstadoHistory<State>>, );\n\t\tPromise.resolve().then( () => afterChange( history as Immutable<EstadoHistory<State>>, ), );\n\t\treturn nextHistory;\n\t}\n\n\tfunction getDraft( stateHistoryPath: unknown, ) {\n\t\tconst [\n\t\t\t_draft,\n\t\t\t_finalize,\n\t\t] = create(\n\t\t\t{\n\t\t\t\tinitial: history.initial,\n\t\t\t\tstate: history.state,\n\t\t\t},\n\t\t\t{ strict: true, },\n\t\t);\n\n\t\tfunction finalize() {\n\t\t\tconst next = _finalize();\n\t\t\tlet {\n\t\t\t\tinitial,\n\t\t\t\tstate,\n\t\t\t} = next;\n\n\t\t\tconst hasNoStateChanges = compare( history.state, state, 'state', ['state',], );\n\t\t\tconst hasNoInitialChanges = compare( history.initial, initial, 'initial', ['initial',], );\n\n\t\t\tif ( hasNoStateChanges && hasNoInitialChanges ) {\n\t\t\t\treturn history;\n\t\t\t}\n\n\t\t\tif ( hasNoStateChanges ) {\n\t\t\t\tstate = history.state;\n\t\t\t}\n\n\t\t\tif ( hasNoInitialChanges ) {\n\t\t\t\tinitial = history.initial;\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\tchanges,\n\t\t\t} = findChanges(\n\t\t\t\tinitial,\n\t\t\t\tstate,\n\t\t\t\tcompare as CompareCallbackReturn,\n\t\t\t);\n\t\t\tconst nextHistory: EstadoHistory<State> = {\n\t\t\t\tchanges: changes as EstadoHistory<State>['changes'],\n\t\t\t\tpriorInitial: initial !== history.initial ? history.initial : history.priorInitial,\n\t\t\t\tstate,\n\t\t\t\tinitial,\n\t\t\t\tpriorState: state !== history.state ? history.state : history.priorState,\n\t\t\t};\n\n\t\t\treturn setHistory( nextHistory, );\n\t\t}\n\n\t\tconst draft: Draft<{\n\t\t\tinitial: State\n\t\t\tstate: State\n\t\t}> = _draft;\n\n\t\tif ( typeof stateHistoryPath === 'string' ) {\n\t\t\tconst value = getDeepArrayPath(\n\t\t\t\t_draft,\n\t\t\t\tgetCacheStringPathToArray( arrayPathMap, stateHistoryPath, ),\n\t\t\t);\n\t\t\tif ( value == null || !isDraft( value, ) ) {\n\t\t\t\tthrow new Error( `Key path ${stateHistoryPath} cannot be a draft. It's value is ${draft} of type ${typeof draft}`, );\n\t\t\t}\n\t\t\treturn [\n\t\t\t\tvalue,\n\t\t\t\tfinalize,\n\t\t\t] as const;\n\t\t}\n\n\t\treturn [\n\t\t\tdraft,\n\t\t\tfinalize,\n\t\t] as const;\n\t}\n\n\tfunction _set( ...args: [targetStatePath?: 'state' | 'initial', unknown?, unknown?,] ) {\n\t\tconst [\n\t\t\ttargetStatePath,\n\t\t\t...props\n\t\t] = args;\n\n\t\tconst [draft, finalize,] = getDraft( targetStatePath, );\n\n\t\tconst [\n\t\t\tstatePath,\n\t\t\tnextState,\n\t\t] = props;\n\n\t\tif ( props.length === 1 ) {\n\t\t\tif ( typeof statePath === 'function' ) {\n\t\t\t\tconst callBackProps = {\n\t\t\t\t\t...history,\n\t\t\t\t\tdraft,\n\t\t\t\t};\n\t\t\t\tstatePath( callBackProps, );\n\t\t\t}\n\t\t}\n\t\telse if ( typeof statePath === 'string' || Array.isArray( statePath, ) ) {\n\t\t\tconst arrayPath = ( typeof statePath === 'string' ? getCacheStringPathToArray( arrayPathMap, statePath, ) : statePath ) as string[];\n\t\t\tconst penPath = arrayPath.at( -1, );\n\t\t\tconst [\n\t\t\t\tvalue,\n\t\t\t\tparent,\n\t\t\t] = getDeepValueParentByArray( draft, arrayPath, );\n\n\t\t\tif ( typeof nextState === 'function' && value && typeof value === 'object' ) {\n\t\t\t\tnextState(\n\t\t\t\t\tcreateArrayPathProxy( value, history, arrayPath.slice( 1, ), ),\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if ( parent && typeof parent === 'object' && typeof penPath !== 'undefined' && penPath in parent ) {\n\t\t\t\tif ( typeof nextState === 'function' ) {\n\t\t\t\t\tconst result = nextState(\n\t\t\t\t\t\tcreateArrayPathProxy( parent, history, arrayPath.slice( 1, ), ),\n\t\t\t\t\t);\n\t\t\t\t\tReflect.set( parent, penPath, result, );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReflect.set( parent, penPath, nextState, );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn finalize();\n\t}\n\n\tconst props: CreateActsProps<State> = {\n\t\tget<State extends DS, StateHistoryPath extends NestedRecordKeys<EstadoHistory<State>>,>(\n\t\t\tstateHistoryPath?: StateHistoryPath,\n\t\t): {\n\t\t\treadonly changes: Immutable<State extends ( infer U )[] ? ( U | undefined )[] : State extends EstadoRecord ? Partial<State> : never> | undefined\n\t\t\treadonly initial: Immutable<State>\n\t\t\treadonly priorState: Immutable<State> | undefined\n\t\t\treadonly priorInitial: Immutable<State> | undefined\n\t\t\treadonly state: Immutable<State>\n\t\t} | Immutable<GetStringPathValue<State, StateHistoryPath>> {\n\t\t\tif ( stateHistoryPath == null ) {\n\t\t\t\t// No argument version\n\t\t\t\treturn history as Immutable<EstadoHistory<State>>;\n\t\t\t}\n\t\t\treturn getDeepArrayPath(\n\t\t\t\thistory,\n\t\t\t\tgetCacheStringPathToArray( arrayPathMap, stateHistoryPath, ),\n\t\t\t) as Immutable<GetStringPathValue<State, typeof stateHistoryPath>>;\n\t\t},\n\t\tgetDraft: getDraft as GetDraftRecord<State>['getDraft'],\n\t\treset() {\n\t\t\tif ( history.changes == null ) {\n\t\t\t\treturn history;\n\t\t\t}\n\n\t\t\treturn setHistory( {\n\t\t\t\tinitial: history.initial,\n\t\t\t\tchanges: undefined,\n\t\t\t\tpriorInitial: history.priorInitial == null ? undefined : history.initial,\n\t\t\t\tpriorState: history.priorState == null ? undefined : history.state,\n\t\t\t\tstate: history.initial,\n\t\t\t}, );\n\t\t},\n\t\tset( ...args: unknown[] ) {\n\t\t\treturn _set( undefined, ...args, );\n\t\t},\n\t};\n\n\treturn props;\n}\n"],"names":[],"version":3,"file":"createCon.b965a764.js.map"}